//@version=6
indicator("Terraline-like Zones + Probabilistic Reaction Interpreter (v1)", overlay=true, max_labels_count=500, max_boxes_count=200)

// ============================================================
// Inputs
// ============================================================
grpZones = "Zone Engine"
maxZones      = input.int(12,  "Max zones kept", minval=4, maxval=40, group=grpZones)
pivotL        = input.int(5,   "Pivot Left", minval=2, maxval=20, group=grpZones)
pivotR        = input.int(5,   "Pivot Right", minval=2, maxval=20, group=grpZones)
atrLen        = input.int(14,  "ATR Length", minval=5, maxval=100, group=grpZones)
zoneWidthK    = input.float(0.40, "Zone half-width (ATR * k)", step=0.05, minval=0.05, maxval=2.0, group=grpZones)
mergeOverlap  = input.float(0.60, "Merge if overlap >= fraction", step=0.05, minval=0.10, maxval=0.95, group=grpZones)
mergeCenterK  = input.float(0.30, "Merge if centers within ATR*k", step=0.05, minval=0.05, maxval=2.0, group=grpZones)
keepSup       = input.int(2, "Active supports below price", minval=1, maxval=5, group=grpZones)
keepRes       = input.int(2, "Active resistances above price", minval=1, maxval=5, group=grpZones)
ttlBars       = input.int(400, "Zone TTL bars (0=off)", minval=0, maxval=5000, group=grpZones)

grpSess = "Session / Fatigue"
useSessions   = input.bool(true, "Session-aware decay", group=grpSess)
sessAsia      = input.session("0000-0800", "Asia session", group=grpSess)
sessLondon    = input.session("0800-1600", "London session", group=grpSess)
sessNY        = input.session("1600-2359", "NY session", group=grpSess)
decayIntra    = input.float(0.995, "TouchPressure decay intra-session", step=0.001, minval=0.900, maxval=0.999, group=grpSess)
decayInter    = input.float(0.85,  "TouchPressure decay at session change", step=0.01,  minval=0.10,  maxval=0.99,  group=grpSess)
exitEpsK      = input.float(0.30,  "Exit eps (ATR*k) to reset touch", step=0.05, minval=0.05, maxval=2.0, group=grpSess)
epsK          = input.float(0.10,  "Zone eps (ATR*k) for pierce/hold", step=0.01, minval=0.01, maxval=1.0, group=grpSess)

grpReact = "Reaction Interpreter"
lookApproach  = input.int(5, "Approach window (bars)", minval=3, maxval=20, group=grpReact)
lookReact     = input.int(5, "Reaction window (bars)", minval=3, maxval=20, group=grpReact)
dispK         = input.float(0.60, "Displacement threshold (ATR*k)", step=0.05, minval=0.10, maxval=3.0, group=grpReact)
holdBars      = input.int(2, "Hold bars for Slice evidence", minval=1, maxval=5, group=grpReact)
minConf       = input.float(0.60, "Min confidence for alerts", step=0.01, minval=0.05, maxval=0.95, group=grpReact)
showLabels    = input.bool(true, "Show classification labels", group=grpReact)
showZones     = input.bool(true, "Draw zones", group=grpReact)
debugActive   = input.bool(false, "Debug: show live probs (top)", group=grpReact)

grpBB = "Bollinger Context"
bbLen        = input.int(20, "BB length", minval=5, maxval=200, group=grpBB)
bbMult       = input.float(2.0, "BB stdev", step=0.1, minval=0.5, maxval=4.0, group=grpBB)
bbWalkCloses = input.int(2, "Band-walk closes", minval=2, maxval=5, group=grpBB)

// ============================================================
// Derived series
// ============================================================
atr  = ta.atr(atrLen)
eps  = epsK * atr
exitEps = exitEpsK * atr
dispThr = dispK * atr

mid = ta.sma(close, bbLen)
dev = bbMult * ta.stdev(close, bbLen)
upper = mid + dev
lower = mid - dev
bbWidthN = (upper - lower) / math.max(mid, syminfo.mintick)

bbTouchLower = low <= lower
bbTouchUpper = high >= upper
bbWalkUp = close > upper and ta.barssince(close <= upper) > (bbWalkCloses - 1)
bbWalkDn = close < lower and ta.barssince(close >= lower) > (bbWalkCloses - 1)

// crude “squeeze” proxy (no percentile in Pine): width near its 252-bar low-ish
bbWidthMin = ta.lowest(bbWidthN, 252)
bbSqueeze  = bbWidthN <= bbWidthMin * 1.15

// ============================================================
// Session change detection (optional)
// ============================================================
inAsia   = not na(time(timeframe.period, sessAsia))
inLondon = not na(time(timeframe.period, sessLondon))
inNY     = not na(time(timeframe.period, sessNY))

sessId = inAsia ? 1 : inLondon ? 2 : inNY ? 3 : 0
var int prevSessId = sessId
newSession = useSessions ? (sessId != prevSessId) : false
prevSessId := sessId

decayFactor = useSessions ? (newSession ? decayInter : decayIntra) : decayIntra

// ============================================================
// Zone store (arrays)
// Each zone: low, high, createdBar, validated, touchPressure, inInteraction, boxId
// ============================================================
var zonesLow   = array.new_float()
var zonesHigh  = array.new_float()
var zonesBorn  = array.new_int()
var zonesValid = array.new_bool()
var zonesTP    = array.new_float()
var zonesInInt = array.new_bool()
var zonesBox   = array.new_box()

// Helper: clamp
f_clamp(x, lo, hi) =>
    math.max(lo, math.min(hi, x))

// Helper: overlap fraction between intervals [a1,a2], [b1,b2]
f_overlapFrac(a1, a2, b1, b2) =>
    lo = math.max(a1, b1)
    hi = math.min(a2, b2)
    inter = math.max(0.0, hi - lo)
    uni = math.max(1e-9, (a2 - a1) + (b2 - b1) - inter)
    inter / uni

// Helper: merge zones at index i into j (j keeps)
f_merge_into(i, j) =>
    li = array.get(zonesLow, i)
    hi = array.get(zonesHigh, i)
    lj = array.get(zonesLow, j)
    hj = array.get(zonesHigh, j)
    // merged bounds
    array.set(zonesLow, j, math.min(li, lj))
    array.set(zonesHigh, j, math.max(hi, hj))
    // merge touchPressure + validated (simple)
    array.set(zonesTP, j, array.get(zonesTP, j) + array.get(zonesTP, i))
    array.set(zonesValid, j, array.get(zonesValid, j) or array.get(zonesValid, i))
    // delete i (and its box)
    bi = array.get(zonesBox, i)
    if not na(bi)
        box.delete(bi)
    array.remove(zonesLow, i)
    array.remove(zonesHigh, i)
    array.remove(zonesBorn, i)
    array.remove(zonesValid, i)
    array.remove(zonesTP, i)
    array.remove(zonesInInt, i)
    array.remove(zonesBox, i)

// Helper: create zone
f_add_zone(center) =>
    w = math.max(zoneWidthK * atr, syminfo.mintick * 10)
    zl = center - w
    zh = center + w
    // append
    array.push(zonesLow, zl)
    array.push(zonesHigh, zh)
    array.push(zonesBorn, bar_index)
    array.push(zonesValid, false)
    array.push(zonesTP, 0.0)
    array.push(zonesInInt, false)
    // create box placeholder
    b = na
    if showZones
        b := box.new(left=bar_index, top=zh, right=bar_index+1, bottom=zl, border_width=1)
        box.set_extend(b, extend.right)
    array.push(zonesBox, b)

// ============================================================
// Zone creation via pivots
// ============================================================
ph = ta.pivothigh(high, pivotL, pivotR)
pl = ta.pivotlow(low, pivotL, pivotR)

if not na(ph)
    f_add_zone(ph)
if not na(pl)
    f_add_zone(pl)

// ============================================================
// Merge pass (cheap O(n^2), n small)
// ============================================================
n = array.size(zonesLow)
if n > 1
    // multiple passes to catch cascades
    for pass = 0 to 1
        i = 0
        while i < array.size(zonesLow)
            j = i + 1
            while j < array.size(zonesLow)
                li = array.get(zonesLow, i)
                hi = array.get(zonesHigh, i)
                lj = array.get(zonesLow, j)
                hj = array.get(zonesHigh, j)
                oi = f_overlapFrac(li, hi, lj, hj)
                ci = (li + hi) * 0.5
                cj = (lj + hj) * 0.5
                centersClose = math.abs(ci - cj) <= (mergeCenterK * atr)
                if oi >= mergeOverlap or centersClose
                    // merge smaller index into i (keep i)
                    f_merge_into(j, i)
                    // don't advance j (array shrank)
                else
                    j += 1
            i += 1

// ============================================================
// Cap zone count (drop oldest first)
// ============================================================
while array.size(zonesLow) > maxZones
    // find oldest (smallest born)
    oldestIdx = 0
    oldestBorn = array.get(zonesBorn, 0)
    for i = 1 to array.size(zonesBorn) - 1
        b = array.get(zonesBorn, i)
        if b < oldestBorn
            oldestBorn := b
            oldestIdx := i
    // delete oldest
    bOld = array.get(zonesBox, oldestIdx)
    if not na(bOld)
        box.delete(bOld)
    array.remove(zonesLow, oldestIdx)
    array.remove(zonesHigh, oldestIdx)
    array.remove(zonesBorn, oldestIdx)
    array.remove(zonesValid, oldestIdx)
    array.remove(zonesTP, oldestIdx)
    array.remove(zonesInInt, oldestIdx)
    array.remove(zonesBox, oldestIdx)

// ============================================================
// TTL retirement
// ============================================================
if ttlBars > 0
    i = 0
    while i < array.size(zonesLow)
        born = array.get(zonesBorn, i)
        if bar_index - born > ttlBars
            bx = array.get(zonesBox, i)
            if not na(bx)
                box.delete(bx)
            array.remove(zonesLow, i)
            array.remove(zonesHigh, i)
            array.remove(zonesBorn, i)
            array.remove(zonesValid, i)
            array.remove(zonesTP, i)
            array.remove(zonesInInt, i)
            array.remove(zonesBox, i)
        else
            i += 1

// ============================================================
// Update zone boxes (color by lifecycle/fatigue)
// ============================================================
for i = 0 to array.size(zonesLow) - 1
    zl = array.get(zonesLow, i)
    zh = array.get(zonesHigh, i)
    tp = array.get(zonesTP, i) * decayFactor  // decay applied here (see also below)
    array.set(zonesTP, i, tp)

    fatigue = f_clamp(tp / 6.0, 0.0, 1.0)
    zoneState = fatigue < 0.30 ? 0 : fatigue < 0.65 ? 1 : 2

    bx = array.get(zonesBox, i)
    if showZones and na(bx)
        bx := box.new(left=bar_index, top=zh, right=bar_index+1, bottom=zl, border_width=1)
        box.set_extend(bx, extend.right)
        array.set(zonesBox, i, bx)

    if showZones and not na(bx)
        box.set_top(bx, zh)
        box.set_bottom(bx, zl)
        // lifecycle tint (no fixed colors requested; use subtle alpha only)
        // (TradingView requires colors; we keep it minimal and consistent)
        col = zoneState == 0 ? color.new(color.green, 85) :
              zoneState == 1 ? color.new(color.orange, 85) :
                               color.new(color.red, 85)
        box.set_bgcolor(bx, col)
        box.set_border_color(bx, color.new(color.gray, 60))

// ============================================================
// Active zone selection: nearest supports/resistances around price
// ============================================================
var activeIdx = array.new_int()

array.clear(activeIdx)
last = array.size(zonesLow)
if last > 0
    // collect candidates with distance
    // Supports: zones whose high <= close (below or at price) OR zone contains price (treat as both)
    // Resistances: zones whose low >= close (above or at price) OR contains price
    // We'll pick closest by distance to zone edge.
    // Support picks:
    for pick = 0 to keepSup - 1
        bestI = na
        bestD = 1e12
        for i = 0 to last - 1
            zl = array.get(zonesLow, i)
            zh = array.get(zonesHigh, i)
            already = false
            for k = 0 to array.size(activeIdx) - 1
                if array.get(activeIdx, k) == i
                    already := true
            if already
                continue
            // support candidate if zone below or contains price
            isSup = (zh <= close) or (close >= zl and close <= zh)
            if isSup
                d = close >= zl and close <= zh ? 0.0 : (close - zh)
                if d < bestD
                    bestD := d
                    bestI := i
        if not na(bestI)
            array.push(activeIdx, bestI)

    // Resistance picks:
    for pick = 0 to keepRes - 1
        bestI = na
        bestD = 1e12
        for i = 0 to last - 1
            zl = array.get(zonesLow, i)
            zh = array.get(zonesHigh, i)
            already = false
            for k = 0 to array.size(activeIdx) - 1
                if array.get(activeIdx, k) == i
                    already := true
            if already
                continue
            isRes = (zl >= close) or (close >= zl and close <= zh)
            if isRes
                d = close >= zl and close <= zh ? 0.0 : (zl - close)
                if d < bestD
                    bestD := d
                    bestI := i
        if not na(bestI)
            array.push(activeIdx, bestI)

// ============================================================
// Touch tracking per zone (debounced by exit)
// TouchPressure increments on NEW touch event (not while lingering)
// ============================================================
for k = 0 to array.size(activeIdx) - 1
    i = array.get(activeIdx, k)
    zl = array.get(zonesLow, i)
    zh = array.get(zonesHigh, i)

    touchZone = (high >= zl and low <= zh)
    inInteraction = array.get(zonesInInt, i)

    exited = (close > zh + exitEps) or (close < zl - exitEps)

    newTouch = (not inInteraction) and touchZone
    if newTouch
        // severity weighting
        inZoneClose = (close >= zl and close <= zh)
        sliceAttempt = (close > zh + eps) or (close < zl - eps)
        touchW = inZoneClose ? 1.0 : 0.7
        touchW += sliceAttempt ? 0.6 : 0.0

        array.set(zonesTP, i, array.get(zonesTP, i) + touchW)
        array.set(zonesInInt, i, true)

    if inInteraction and exited
        array.set(zonesInInt, i, false)

// ============================================================
// Reaction episode engine (one episode at a time, for the first active zone that is touched)
// ============================================================
f_distToZone(zl, zh) =>
    close < zl ? (zl - close) : close > zh ? (close - zh) : 0.0

f_approachId(zl, zh) =>
    // compute approach scores (FAST/DRIFT/STAIR/CLIMAX) over lookApproach
    // only meaningful if distance is positive and decreasing overall
    dNow = f_distToZone(zl, zh)
    dPrev = f_distToZone(zl, zh)[1]
    approaching = (dNow > 0) and (dPrev > 0) and (dNow < dPrev)

    // Normalize helpers
    vRatio = volume / math.max(ta.sma(volume, 20), 1)
    rangeN = (high - low) / math.max(atr, syminfo.mintick)
    bodyN  = math.abs(close - open) / math.max(atr, syminfo.mintick)
    closePos = (close - low) / math.max(high - low, syminfo.mintick)

    fastScore   = approaching ? f_clamp((ta.sma(rangeN, lookApproach) - 1.0) + (ta.sma(bodyN, lookApproach) - 0.5) + (ta.sma(vRatio, lookApproach) - 1.0), 0.0, 1.0) : 0.0
    driftScore  = approaching ? f_clamp((0.9 - ta.sma(rangeN, lookApproach)) + (0.5 - ta.sma(bodyN, lookApproach)), 0.0, 1.0) : 0.0
    flips = ta.sum(ta.change(math.sign(close - open)) != 0 ? 1 : 0, lookApproach)
    stairScore  = approaching ? f_clamp(flips / 3.0, 0.0, 1.0) : 0.0
    climaxScore = approaching ? f_clamp((rangeN > 1.8 ? 0.6 : 0.0) + (vRatio > 1.5 ? 0.4 : 0.0) + ((closePos > 0.75 or closePos < 0.25) ? 0.2 : 0.0), 0.0, 1.0) : 0.0

    // pick dominant
    climaxScore > fastScore and climaxScore > driftScore and climaxScore > stairScore ? 3 :
     fastScore > driftScore and fastScore > stairScore ? 0 :
     driftScore > stairScore ? 1 : 2

f_priors(approachId) =>
    // returns array [Rj, Ac, Cp, Sl, Sw]
    approachId == 0 ? array.from(0.12, 0.10, 0.18, 0.40, 0.20) :
    approachId == 1 ? array.from(0.18, 0.34, 0.30, 0.10, 0.08) :
    approachId == 2 ? array.from(0.16, 0.20, 0.36, 0.18, 0.10) :
                      array.from(0.20, 0.08, 0.12, 0.22, 0.38)

f_renorm(pRj, pAc, pCp, pSl, pSw) =>
    s = pRj + pAc + pCp + pSl + pSw
    s <= 0 ? array.from(0.2,0.2,0.2,0.2,0.2) : array.from(pRj/s, pAc/s, pCp/s, pSl/s, pSw/s)

// Episode state
var bool epActive = false
var int  epZoneI = na
var int  epStep = 0

var float sRj = 0.0, sAc = 0.0, sCp = 0.0, sSl = 0.0, sSw = 0.0
var float pRj0 = 0.2, pAc0 = 0.2, pCp0 = 0.2, pSl0 = 0.2, pSw0 = 0.2

var float P_Rj = na, P_Ac = na, P_Cp = na, P_Sl = na, P_Sw = na
var string lastDom = ""
var float lastConf = na

// Start episode if any active zone is touched and no episode active
if not epActive and array.size(activeIdx) > 0
    // choose first touched among active zones (nearest-first due to selection loop)
    chosen = na
    for k = 0 to array.size(activeIdx) - 1
        i = array.get(activeIdx, k)
        zl = array.get(zonesLow, i)
        zh = array.get(zonesHigh, i)
        touch = (high >= zl and low <= zh)
        if touch and na(chosen)
            chosen := i
    if not na(chosen)
        epActive := true
        epZoneI := chosen
        epStep := 0
        sRj := 0, sAc := 0, sCp := 0, sSl := 0, sSw := 0

        zl = array.get(zonesLow, epZoneI)
        zh = array.get(zonesHigh, epZoneI)

        // base priors from approach
        aId = f_approachId(zl, zh)
        pr = f_priors(aId)
        pRj = array.get(pr,0)
        pAc = array.get(pr,1)
        pCp = array.get(pr,2)
        pSl = array.get(pr,3)
        pSw = array.get(pr,4)

        // bollinger nudges
        if (bbTouchLower or bbTouchUpper)
            pRj += 0.08
            pSw += 0.06
            pAc -= 0.06
        if (bbWalkUp or bbWalkDn)
            pSl += 0.10
            pRj -= 0.08
        if bbSqueeze
            pCp += 0.10
            pSw -= 0.05

        // fatigue/lifecycle nudges (touchPressure already decayed)
        tp = array.get(zonesTP, epZoneI)
        fatigue = f_clamp(tp / 6.0, 0.0, 1.0)
        zoneState = fatigue < 0.30 ? 0 : fatigue < 0.65 ? 1 : 2

        if zoneState == 0
            pRj += 0.10
            pSw += 0.06
            pSl -= 0.10
        if zoneState == 1
            pCp += 0.08
            pSl += 0.10
            pRj -= 0.08
        if zoneState == 2
            pSl += 0.18
            pCp += 0.08
            pRj -= 0.18
            pSw -= 0.06

        // renorm & store as priors
        pr2 = f_renorm(pRj, pAc, pCp, pSl, pSw)
        pRj0 := array.get(pr2,0)
        pAc0 := array.get(pr2,1)
        pCp0 := array.get(pr2,2)
        pSl0 := array.get(pr2,3)
        pSw0 := array.get(pr2,4)

// Episode update (bar-by-bar)
if epActive and not na(epZoneI)
    epStep += 1

    zl = array.get(zonesLow, epZoneI)
    zh = array.get(zonesHigh, epZoneI)

    inZone = (close >= zl and close <= zh)
    pierceUp  = high > zh + eps
    pierceDn  = low  < zl - eps
    closeAbove = close > zh + eps
    closeBelow = close < zl - eps

    wickUpN = (high - math.max(open, close)) / math.max(atr, syminfo.mintick)
    wickDnN = (math.min(open, close) - low) / math.max(atr, syminfo.mintick)
    dispAwayN = math.max(math.abs(close - zh), math.abs(close - zl)) / math.max(atr, syminfo.mintick)
    rangeN = (high - low) / math.max(atr, syminfo.mintick)

    // Evidence deltas
    // Sweep: pierce then close back inside
    if (pierceUp and close <= zh) or (pierceDn and close >= zl)
        sSw += 0.8
    sSw += 0.4 * math.max(wickUpN, wickDnN)

    // Slice: close beyond + hold + displacement
    if closeAbove or closeBelow
        sSl += 0.6
    if holdBars >= 2
        if (closeAbove and closeAbove[1]) or (closeBelow and closeBelow[1])
            sSl += 0.4
    sSl += 0.3 * dispAwayN

    // Acceptance: closes in-zone
    if inZone
        sAc += 0.35

    // Rejection: displacement away without hanging in-zone (simple heuristic)
    if not inZone and (dispAwayN * atr) > dispThr
        sRj += 0.45
    // wick “into” zone adds rejection evidence
    sRj += 0.15 * ((pierceUp ? wickUpN : 0.0) + (pierceDn ? wickDnN : 0.0))

    // Compression: in-zone and range shrinking
    if inZone and (rangeN < rangeN[1])
        sCp += 0.35

    // Convert (prior + scores) to probabilities via softmax-like logits
    lRj = math.log(math.max(pRj0, 1e-9)) + sRj
    lAc = math.log(math.max(pAc0, 1e-9)) + sAc
    lCp = math.log(math.max(pCp0, 1e-9)) + sCp
    lSl = math.log(math.max(pSl0, 1e-9)) + sSl
    lSw = math.log(math.max(pSw0, 1e-9)) + sSw

    eRj = math.exp(lRj)
    eAc = math.exp(lAc)
    eCp = math.exp(lCp)
    eSl = math.exp(lSl)
    eSw = math.exp(lSw)
    denom = eRj + eAc + eCp + eSl + eSw

    P_Rj := eRj / denom
    P_Ac := eAc / denom
    P_Cp := eCp / denom
    P_Sl := eSl / denom
    P_Sw := eSw / denom

    // Debug: show top prob live
    if debugActive
        topP = math.max(P_Rj, math.max(P_Ac, math.max(P_Cp, math.max(P_Sl, P_Sw))))
        dom = topP == P_Rj ? "REJECT" :
              topP == P_Ac ? "ACCEPT" :
              topP == P_Cp ? "COMPRESS" :
              topP == P_Sl ? "SLICE" : "SWEEP"
        label.new(bar_index, high, dom + " " + str.tostring(topP*100, "#.0") + "%", style=label.style_label_down, textcolor=color.white, color=color.new(color.black, 70))

    // Finish episode
    if epStep >= lookReact
        topP = math.max(P_Rj, math.max(P_Ac, math.max(P_Cp, math.max(P_Sl, P_Sw))))
        dom = topP == P_Rj ? "REJECT" :
              topP == P_Ac ? "ACCEPT" :
              topP == P_Cp ? "COMPRESS" :
              topP == P_Sl ? "SLICE" : "SWEEP"

        lastDom := dom
        lastConf := topP

        if showLabels
            label.new(bar_index, high, dom + "  " + str.tostring(topP*100, "#.0") + "%", style=label.style_label_down, textcolor=color.white, color=color.new(color.black, 60))

        // Simple validation rule: if we got strong REJECT or SWEEP, mark zone validated
        if (dom == "REJECT" or dom == "SWEEP") and topP >= 0.55
            array.set(zonesValid, epZoneI, true)

        epActive := false
        epZoneI := na
        epStep := 0

// ============================================================
// Alerts (ranked)
// Fires on episode completion
// ============================================================
epDone = (not epActive) and (lastDom != "") and (not na(lastConf)) and (lastConf >= minConf)

alertcondition(epDone and lastDom == "REJECT",  "Reaction: REJECT",  "REJECT with confidence >= threshold")
alertcondition(epDone and lastDom == "ACCEPT",  "Reaction: ACCEPT",  "ACCEPT with confidence >= threshold")
alertcondition(epDone and lastDom == "COMPRESS","Reaction: COMPRESS","COMPRESS with confidence >= threshold")
alertcondition(epDone and lastDom == "SLICE",   "Reaction: SLICE",   "SLICE with confidence >= threshold")
alertcondition(epDone and lastDom == "SWEEP",   "Reaction: SWEEP",   "SWEEP with confidence >= threshold")

// ============================================================
// Optional: plot something lightweight in data window
// ============================================================
plotchar(epActive ? P_Rj : na, "P(REJECT)", "", location=location.top, display=display.data_window)
plotchar(epActive ? P_Ac : na, "P(ACCEPT)", "", location=location.top, display=display.data_window)
plotchar(epActive ? P_Cp : na, "P(COMPRESS)", "", location=location.top, display=display.data_window)
plotchar(epActive ? P_Sl : na, "P(SLICE)", "", location=location.top, display=display.data_window)
plotchar(epActive ? P_Sw : na, "P(SWEEP)", "", location=location.top, display=display.data_window)
